---
title: "funModeling Index"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using funModeling in predictive modeling}
  %\VignetteEngine{knitr::knitr}
---

Selecting Best Variables Analysis
====

## Introduction
This vignette will cover three type of plots which aim to understand what are the more numeric correlated variables against a target variable.


* **Overview**:
    + **Analysis purpose**: To identify if the input variable is a good/bad predictor through visual analysis. 
    + **General purpose**: To explain the decision of including -or not- a variable to a model to a *non-analyst* person. 

**Constraint:** Target variable must have only 2 values. If it has `NA` values, they will be removed.

*Note: Please note there are many ways for selecting best variables to build a model, here is presented one more based on visual analysis.*
<br>
<br>

-----------------------

## Part A) Target Profiling with Histograms


```r
## Loading funModeling !
suppressMessages(library(funModeling))

plotar(data=heart_disease, str_input="age", str_target="has_heart_disease", plot_type = "histdens")
```

![plot of chunk variable_importance1](figure/variable_importance1-1.png) 

_Dashed-line represents variable mean._

**Density histograms** are nice to visualize the general shape of a numeric distrubition.

This *general shape* is calculated based on a technique called **Kernel Smoother**, its general idea is to reduce high/low peaks (noise) present in near points/bars by estimating the function that describes the points. Here some pictures to ilustrate the concept: https://en.wikipedia.org/wiki/Kernel_smoother

<br>



_Something similar is what an **statistical test** sees: they measured **how different** the curves are reflecting it in some statistics (like the p-value), in order to give to the analyst, a  reliable information to determine if the curves have -for example- the same mean._

<br>
<br>

### A.1) Hist. Dens.: Good vs. Bad variable


```r
plotar(data=heart_disease, str=c('resting_blood_pressure', 'max_heart_rate'),  str_target="has_heart_disease", plot_type = "histdens")
```

![plot of chunk variable_importance2](figure/variable_importance2-1.png) ![plot of chunk variable_importance2](figure/variable_importance2-2.png) 
<br>
And the model will see the same... if the curves are quite overlapped, like it is in `resting_blood_pressure`, then it's **not a good predictor** as if they were **more spaced** -like `max_heart_rate`.

<br>
<br>

----

## Part B) Target Profiling with Boxplots


```r
plotar(data=heart_disease, str_input="age", str_target="has_heart_disease", plot_type = "boxplot")
```

![plot of chunk variable_importance2b](figure/variable_importance2b-1.png) 

_Romboid near the mean line represents the **median**._

<br>


![](boxplot.png)

<br>

*When to use boxplots?*
When you need to analyze different percentiles across the classes to predict. Note this is a powerful technique since the bias produced due to outliers doesn't affect as much as it does to the mean.


### B.1) Boxplot: Good vs. Bad variable
plotar(data=heart_disease, str=c('max_heart_rate', 'resting_blood_pressure'),  str_target="has_heart_disease", plot_type = "boxplot")

`max_heart_rate` is cleraly a better predictor than `resting_blood_pressure`.

As a general rule, a variable will rank as **more important** if boxplots are **not aligned** horizontally.

_Statistcal tests: percentiles are another used feature used by them in order to determine -for example- if means across groups are or not the same._

### Exporting plots
`plotar` and `cross_plot` can handle from 1 to N input variables, and plots generated by them can be easily exported in high quality with parameter `path_out`.

```r
plotar(data=heart_disease, str=c('max_heart_rate', 'resting_blood_pressure'),  str_target="has_heart_disease", plot_type = "boxplot", path_out = "my_awsome_folder")
```

<br>
<br>
-----------------------

## Part C) Target Profiling with `cross_plot` 

### Example C.1: Is gender correlated with heart disease?

```r
cross_gender=cross_plot(heart_disease, str_input="gender", str_target="has_heart_disease")
```

![plot of chunk variable_importance_c1](figure/variable_importance_c1-1.png) 

Last two plots have the same data source, showing the distribution of `has_heart_disease` in terms of `gender`. The one on the left shows in percentage value, while the one on the right shows in absolute value.

#### How to extract conclusions from the plots? (Short version)
`Gender` variable seems to be a **good predictor**, since the likelihood of having heart disease is different given the female/male groups.  **it gives an order to the data**.

#### How to extract conclusions from the plots? (Long version)
##### From 1st plot (%):

1. The **likelihood** of having heart disease for males is 55.3%, while for females is: 25.8%.
2. The heart disease rate for males **doubles** the rate for females (55.3 vs 25.8, respectively). 

##### From 2nd plot (count):

1. There are a total of **97 females**:
    + 25 of them have heart disease (25/97=25.8%, which is the ratio of 1st plot).
    + the remaining 72 have not heart disease (74.2%)

2. There are a total of **206 males**:
    + 114 of them have heart disease (55.3%)
    + the remaining 92 have not heart disease (44.7%)

3. Total cases: Summing the values of four bars: 25+72+114+92=**303**.

*Note: What would it happened if instead of having the rates of 25.8% vs. 55.3% (female vs male), they had been more similar like 30.2% vs. 30.6%). In this case variable `gender` it would have been much less relevant, since it doesn't separate the `has_heart_disease` event.*

### Example C.2: Crossing with numerical variables
Numerical variables should be **binned** in order to plot them with an histogram, otherwise the plot is not showing information, as it can be seen here:


#### Equal frequency binning
There is a function included in the package (inherited from Hmisc package) : `equal_freq`, which returns the bins/buckets based on the **equal frequency criteria**. Which is *-or tries to-* have the same quantity of rows per bin.

For numerical variables, `cross_plot` has by default the `auto_binning=T`, which automtically calls the `equal_freq` function with `n_bins=10` (or the closest number).


```r
cross_plot(heart_disease, str_input="max_heart_rate", str_target="has_heart_disease")
```

![plot of chunk variable_importance_c2](figure/variable_importance_c2-1.png) 

### Example C.3: Manual binning
If you don't want the automatic binning, then set the `auto_binning=F` in `cross_plot` function.

For example, creating `oldpeak_2` based on equal frequency, with 3 buckets.


```r
heart_disease$oldpeak_2=equal_freq(var=heart_disease$oldpeak, n_bins = 3)
summary(heart_disease$oldpeak_2)
```

```
## [0.0,0.2) [0.2,1.5) [1.5,6.2] 
##       106       107        90
```

Plotting the binned variable (`auto_binning = F`):

```r
cross_oldpeak_2=cross_plot(heart_disease, str_input="oldpeak_2", str_target="has_heart_disease", auto_binning = F)
```

![plot of chunk variable_importance_c4](figure/variable_importance_c4-1.png) 

#### **Conclusion**
This new plot based on `oldpeak_2` shows clearly how: the likelihood of **having heart disease increases** as **oldpeak_2 increases** as well. *Again, it gives an order to the data.*

### Example C.4: Noise reducing
Converting variable `max_heart_rate` into a one of 10 bins:


```r
heart_disease$max_heart_rate_2=equal_freq(var=heart_disease$max_heart_rate, n_bins = 10)
cross_plot(heart_disease, str_input="max_heart_rate_2", str_target="has_heart_disease")
```

![plot of chunk variable_importance_c5](figure/variable_importance_c5-1.png) 

At a first glance, `max_heart_rate_2` shows a negative and linear relationship, however there are some buckets which add noise to the relationship. For example, the bucket `(141, 146]` has a higher heart disease rate than the previous bucket, and it was expected to have a lower. *This could be noise in data.* 

**Key note**: One way to reduce the **noise** (at the cost of **losing** some information), is to split with less bins:


```r
heart_disease$max_heart_rate_3=equal_freq(var=heart_disease$max_heart_rate, n_bins = 5)
cross_plot(heart_disease, str_input="max_heart_rate_3", str_target="has_heart_disease")
```

![plot of chunk variable_importance_c6](figure/variable_importance_c6-1.png) 

**Conclusion**: As it can be seen, now the relationship is much clean and clear. Bucket *'N'* has a higher rate than *'N+1'*, which implies a negative correlation.


**How about saving the cross_plot result into a folder?**
Just set the parameter `path_out` with the folder you want -It creates a new one if it doesn't exists-.

```r
cross_plot(heart_disease, str_input="max_heart_rate_3", str_target="has_heart_disease", path_out="my_plots")
```
It creates the folder `my_plots` into the working directory. 

### Example C.4: `cross_plot` on multiple variables
Imagine you want to run cross_plot for several variables at the same time. To achieve this goal just define a vector containing the variable names.

If you want to analyze these 3 variables: 

```r
vars_to_analyze=c("age", "oldpeak", "max_heart_rate")
```


```r
cross_plot(data=heart_disease, str_target="has_heart_disease", str_input=vars_to_analyze)
```

<br>
<br>
-----------------------
 
### Part D) Final notes:
* https://en.wikipedia.org/wiki/Correlation_does_not_imply_causation
* `cross_plot` is good to visualize **linear** relationships, giving it a hint on **non-linear** relationships.
* Cleaning the variables help the model to better modelize the data.
